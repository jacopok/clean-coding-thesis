---
# compile with:
# pandoc -f markdown-implicit_figures --citeproc galileian_thesis.md --toc -o galileian_thesis.pdf

title: "Best practices in scientific coding: a case study"
author: Jacopo Tissino
date: October 2022
geometry: "left=3.5cm,right=3.5cm,top=2.5cm,bottom=2.5cm"
output: pdf_document
colorlinks: true
linkcolor: blue
link-citations: true
bibliography: [Galithesis.bib]
abstract: |
  Scientific software is often experimental and thus messy, 
  undocumented, not reusable. As a given piece of software grows 
  in user count, though, it can benefit in applying 
  development best practices which are well-known in the 
  industry setting.  
  This thesis will discuss a selection of these practices and show
  their application for a `python` project named
  `GWFish`, a Fisher matrix code used for gravitational wave
  data analysis.
header-includes: |
  \usepackage{siunitx}



hyperrefoptions:
- linktoc=all
- linkcolor=blue

---

# Introduction

Scientists notoriously write bad code.
This is a thorny statement, and it should be qualified: code may be "bad" 
according to the standards of companies, but if its purpose is the investigation 

Using `GWFish` [@harmsGWFishSimulationSoftware2022] to demostrate 
these software practices is something of a perfect storm. 
It is a very young piece of software (its development started in early 2021)
which serves a conceptually simple purpose, and which 
can be useful to a large amount of people.

## GWFish in short

What follows is a short explanation of what this piece of software does, 
aimed at non-physicists. I will first introduce the concept of gravitational 
wave detection and the purpose of `GWFish` at a general level, without
the mathematical details.
Then, I will go into more detail into the things it needs to compute,
including some math, but still at a level which an undergraduate
in a scientific field should be able to understand.

The first direct measurement of gravitational waves was accomplished 
in 2015 by the LIGO interferometers in the United States.

In 2017 they were joined by the Virgo interferometer in Italy, and
the network has since detected almost 100 distinct signals. 
Most of these signals were generated by pairs of black holes orbiting each other,
with the remaining few corresponding to pairs of neutron stars or one neutron star 
and one black hole.

By lowering the noise in the interferometer, we went from no detection 
to about one signal per week. This has already been called the birth of a 
new era of _gravitational wave astronomy_, which can complement "regular" 
electromagnetic astronomy. 

A lot of interest is going towards the question: how can we do better?
Which kinds of new detectors are best if we want to detect even more 
gravitational waves?
These instruments are big, expensive projects, therefore a careful scientific
evaluation of what we think a new detector concept might be able to 
accomplish is crucial when outlining a funding proposal.

<!-- We have experimental evidence that, at least at a basic level, our understanding
of how gravitational waves are generated and propagate through space 
is correct; therefore, the typical procedure is to extrapolate this knowledge 
in order to evaluate  -->

The basic questions we wish to answer for any new detector concept are:

- which kinds gravitational wave sources will it be able to detect? how many of them?
- how well will it be able to estimate the properties of these sources?

answer to these questions for a wide range of future detector proposals.
The answers necessarily depend on two aspects: 

- given a specific astrophysical source, can _detector X_ measure it? 
  If so, how well?
  - for example, consider a pair of black holes, with masses so-and-so, 
    at a distance of such-and-such...
- how many of that astrophysical source kind are there? how far away are they?
  - for example, what is the distribution of black hole binaries? what are their
    typical masses, how often do they occur in any given universe volume?


`GWFish` is a piece of software built for the purpose of giving an approximate
answer to the _first_ of these questions. The second is much harder to deal with
even for the sources we have direct knowledge of (black holes, neutron stars, white 
dwarfs), bordering on impossible for more exotic and hypothetical sources 

- Matched filtering
- Meaning of SNR
- Fisher matrix error estimation
- 

### Matched filtering

This is a basic technique used for all modern gravitational data analysis.
The idea is that we want to extract a very weak signal which is submerged in noise.
A complete overview of the method can be found in [@maggioreGravitationalWavesVolume2007],
here I will give a very brief one.

The raw strain data from a GW detector looks like this:

![Raw data](figures/bare.pdf)

It is clear that the largest contribution in terms of amplitude is an oscillation
with period on the order of a couple of seconds, and amplitude on the order of a few times $10^{-18}$
(dimensionless strain).

The signal we want to measure is at least three orders of magnitude smaller! What can we do?
The first step is to look at the "Fourier spectrum" of these data (more specifically, the 
amplitude spectral density, but thinking of it as the amplitude of the Fourier transform is not 
terrible):

![Amplitude spectral density](figures/asd.pdf)

We are not even showing the part of the spectrum with period on the order a few seconds,
the trend at low frequency continues and the amplitude for $f \sim \qty{1}{Hz}$ there is enormous. 
This detector is _not sensitive_ to signals with very low frequency, but it _is_ sensitive to 
signals with frequencies in a band around 100Hz. 

The first step towards 

### Fisher matrix error estimation



# Documentation

A crucial aspect in software usability is the presence of good documentation.
In my experience, when this is brought up people's mind often goes to comments
in the code, but 

## The diátaxis framework

The diátaxis framework [@procidaDiataxisDocumentationFramework2022] 
allows us to structure our thinking about documentation
according to the needs of the user, as opposed to our convenience
when writing the code.



## Documentation for GWFish

# Testing

## Testing GWFish

### Unit testing for matrix inversion

Within `GWFish`, an important step is the inversion of the Fisher matrix, which is 
defined as 

$$ F_{ij} = \left( \left.\frac{\partial h}{\partial \theta _i} \right| \frac{\partial h}{\partial \theta _j}\right)\,.
$$

Its inversion is required since the estimates for the errors on single parameters
are given by the diagonal entries in its inverse: 

$$ \sigma _i \approx (F^{-1})_{ii}\,.
$$

This by itself does not seem like a difficult task computationally: 
after all, the matrices at hand are not very large (on the order of $10\times 10$),


# Code structure

## 